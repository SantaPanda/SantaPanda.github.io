[{"title":"笔记--大天使之剑项目的网络传输类图和架构思路","date":"2018-04-26T02:20:24.000Z","path":"2018/04/26/note-2018-4.18/","text":"记录一下现阶段对于该项目的网络传输架构设计的理解。(自用) 1.网络传输协议等相关类图 2.架构思路2.1 Connecter类，负责对项目层所需的网络传输底层逻辑进行的封装。(项目层其他类只需要调用该类的方法即可实现与服务器的数据传输，如何实现socket连接，维持心跳，连接超时等问题交给socketHandler类和Connecter方法解决。) 2.2 Bean和Message类，负责对传输数据的压缩，数据转化二进制流等操作，继承这2个类的相关Message类主要用于对需要传输的数据的描述（添加字段）。因此会在数据传输时被Protocol相关类调用，也会保存在MessagePool里，以供接收数据时对数据的解压（二进制流数据根据字段类型转换为相应的成员变量）。 2.3 BaseProtocol类，负责实现对数据传输的请求发起，会调用相关Message变量和Connecter类的send方法，向服务器发起请求。 因此客户端需要添加新的协议时，只需让新的Protocol继承BaseProtocol类,并添加相应的req方法，对应一个新的Message类记录传输过去的数据内容 2.4 Handler类，负责对于接受到的数据进行相应的逻辑处理，会在客户端接受到数据时，根据相应的cmd号来在MessagePool中找到相对应的Handler类，并且根据相对应的Mesage类来更新message成员变量，然后通过调用action()方法来调用对应的游戏逻辑。因此客户端需要添加新的协议时，只需要把需要实现的游戏逻辑放在相对应的Handler类的action()方法里。 这里只写了大概的思路，具体的逻辑就不写了，有更深理解的话会补充。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"大天使之剑项目笔记","slug":"大天使之剑项目笔记","permalink":"http://yoursite.com/tags/大天使之剑项目笔记/"}]},{"title":"zigzag数字压缩算法&其在二进制流数据中的保存。","date":"2018-04-17T03:57:29.000Z","path":"2018/04/17/zigzag/","text":"先来放一下别人的详细资料–zigzag算法 这里就不复述里面的知识点了，下面来谈谈我对该算法的理解。 1.为什么需要压缩数据？在程序运行过程中，我们需要传输和使用到很多的数据，然而我们传输的整数数据往往比较小，例如一个用户的id,一个商品的id以及每个商品持有的数量等，这些数据往往在0~10000之间比较多，如果使用int类型(32位)或long类型(64位)去记录这些数据的话，当id为1时，其在int中会以00000000_00000000_00000000_00000001这样的二进制形式保存，然而整串二进制数据中有意义的只有那个1，这是简直是对资源的浪费，也会降低网络的传输效率。 那么要做的就是给这些整数数据瘦身。 2.如何压缩整数数据？这里用到的就是巧妙的zigzag算法。 zigzag算法的思想很简单，就是尽可能地减少这些无意义的0，尽可能地只保留有意义的1。那么要怎样做才能减少这些0呢，直接把1前面的0去掉嘛？ 很遗憾，整数除了正整数还包括负整数，负数在二进制中是怎么保存的呢？例如(-1)10 = (11111111_11111111_11111111_11111111)补 zigzag给出了一个很巧的方法：补码的第一位是符号位，他阻碍了我们对于前导0的压缩，那么，我们就把这个符号位放到补码的最后，其他位整体前移一位： (-1)10 = (11111111_11111111_11111111_11111111)补 = (11111111_11111111_11111111_11111111)符号后移 但是即使这样，也是很难压缩的，因为数字绝对值越小，他所含的前导1越多。于是，这个算法就把负数的所有数据位按位求反，符号位保持不变，得到了这样的整数： (-1)10 = (11111111_11111111_11111111_11111111)补 = (11111111_11111111_11111111_11111111)符号后移 = (00000000_00000000_00000000_00000001)zigzag 而对于非负整数，同样的将符号位移动到最后，其他位往前挪一位，数据保持不变。 (1)10 = (00000000_00000000_00000000_00000001)补 = (00000000_00000000_00000000_00000010)符号后移 = (00000000_00000000_00000000_00000010)zigzag 唉，这样一弄就很舒服啦，正数、0、负数都有同样的表示方法了。我们就可以对小整数进行压缩了，对吧~ 结合这些cases，得出的算法就是： 1234public int encodeZigZag32(int n) &#123; return (n &lt;&lt; 1) ^ (n &gt;&gt; 31);&#125; 3.解压数据这一步就要解决我们压缩过的数据。由于上一步压缩的操作，符号位从左边第一位移到了最后一位，除了最后一位剩下的31位就是数据位，要做的就是把数据位还原。 先放代码： 12345public int decodeZigZag32(int n)&#123; //return (((unsignedint)n) &gt;&gt;1) ^ -(n &amp; 1); return (n &gt;&gt;&gt; 1) ^ -(n &amp; 1);&#125; 可以看出(n &gt;&gt;&gt; 1)这步无符号右移操作可以将数据位提取出来，并且与符号位进行异或操作就可以提到原来的数据。(与(-1)的异或操作巧妙在于可以将数据位还原（0，1互换）以及符号位的还原)。 后补充。","tags":[{"name":"数据压缩算法","slug":"数据压缩算法","permalink":"http://yoursite.com/tags/数据压缩算法/"},{"name":"zigzag","slug":"zigzag","permalink":"http://yoursite.com/tags/zigzag/"},{"name":"二进制流数据","slug":"二进制流数据","permalink":"http://yoursite.com/tags/二进制流数据/"}]},{"title":"(转载)Java 观察者模式与事件机制的区别","date":"2018-03-13T06:47:18.000Z","path":"2018/03/13/DesignPattern1/","text":"转载","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Dijkstra算法-单点源最短路径算法笔记","date":"2017-10-11T08:09:14.000Z","path":"2017/10/11/dijkstra/","text":"迪杰斯特拉算法介绍迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 基本思想通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 操作步骤 (1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 (2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。 (3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 (4) 重复步骤(2)和(3)，直到遍历完所有顶点。 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 算法图解 以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。 初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！第1步：将顶点D加入到S中。 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。 注:C(3)表示C到起点D的距离是3。 第2步：将顶点C加入到S中。 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。 第3步：将顶点E加入到S中。 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。 第4步：将顶点F加入到S中。 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。 第5步：将顶点G加入到S中。 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。 第6步：将顶点B加入到S中。 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。 第7步：将顶点A加入到S中。 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。 此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。 Java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.ArrayList;/** * Created by Santa on 17/10/11. */public class Dijkstra &#123; int[] dis; int[] pre;//前继点,用于输出最短路径. public void getMinDistance(int[][] weight, int start)&#123; int n = weight.length; dis = new int[n]; pre = new int[n]; ArrayList&lt;Integer&gt; noVisit = new ArrayList&lt;&gt;(); for(int i=0; i&lt;n; i++)&#123; noVisit.add(i); pre[i] = -1; &#125; //从未选择点中删除起点. noVisit.remove((Integer) start); //迭代直到所有选择点被选中. while (noVisit.size() &gt; 0)&#123; int next = 0; int dMin = Integer.MAX_VALUE; //从未选中点集中选取离点start最近的点作为中转点next. for(int i=0; i&lt;noVisit.size(); i++)&#123; int point = noVisit.get(i); if(weight[start][point] &lt; dMin)&#123; dMin = weight[start][point]; next = point; &#125; &#125; //dis[next]表示点start到点next的最短距离就是weight[start][next]; dis[next] = weight[start][next]; noVisit.remove((Integer) next); //以点next作为中转点,更新经过点next的从点start到未更新点的最短距离. //这部分算法可以确保点start到所有已选取点的距离都是该2点之间的最短路径. for(int i=0; i&lt;noVisit.size(); i++)&#123; int point = noVisit.get(i); if(weight[start][next] + weight[next][point] &lt; weight[start][point])&#123; weight[start][point] = weight[start][next] + weight[next][point]; pre[point] = next; &#125; &#125; &#125; //print部分 for(int i=0; i&lt;n; i++)&#123; System.out.println(\"The distance from \" + start + \" to \" + i + \" is: \" + dis[i]); int temp = i; String path = temp + \"\"; while(pre[temp] != -1)&#123; path = pre[temp] + \" \" + path; temp = pre[temp]; &#125; path = start + \" \" + path; System.out.println(\"The path: \" + path); &#125; &#125; public static void main(String[] args) &#123; int MAX = 100000; //邻接矩阵 int[][] weight = &#123; &#123;0, 1, 3, 10, 2&#125;, &#123;1, 0, 1, MAX, 3&#125;, &#123;3, 1, 0, 3, MAX&#125;, &#123;10, MAX, 3, 0, 6&#125;, &#123;2, 3, MAX, 6, 0&#125; &#125;; Dijkstra d = new Dijkstra(); d.getMinDistance(weight, 0); &#125;&#125; 结果：","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"},{"name":"最短路径","slug":"最短路径","permalink":"http://yoursite.com/tags/最短路径/"}]},{"title":"ip地址和子网掩码的转换","date":"2017-10-03T15:53:18.000Z","path":"2017/10/03/net_ip/","text":"一、标准分类的IP地址每台计算机都要有IP地址，有了IP地址才能互相通信，计算机之间只能互相认识IP地址。IP地址可以理解为计算机的身份证号。 （一）二进制和十进制数转换(★记住)11111111→128＋64＋32＋16＋8＋4＋2＋1＝240＋15＝255举例：10100000→128＋32＝160 反过来160＝128＋32→1010000010011000→128＋16＋8＝15201000100→64＋4＝68 （二）IP地址的表示IPv4地址采用32位的二进制数表示，表示形式为：**.**.**.** (其中*表示1个二进制位，共4组，每组8位二进制数)比如：11000000.10101000.00000101.00010111写成十进制数就是：X.X.X.X（其中X表示0—255之间的一个十进制数），比如：192.168.5.23、218.85.157.99、218.85.152.99 是正确的IP地址。156.56.45、256.45.345.34、56.0.0.1.7 是错误的IP地址。 （三）IP地址的分类(记住)IP地址分为A类、B类、C类、D类、E类，规定如下：A类：网络位8位，主机位24位，网络前导位为0，即：0***.**.**.** 即1.0.0.0—127.255.255.255网络位00000000不可用，网络位01111111(127)表示回送地址，指本地机。B类：网络位16位，主机位16位，网络前导位为10，即：10**.**.**.** 即128.0.0.0—191.255.255.255C类：网络位24位，主机位8位，前导位为110，即：110*.**.**.** 即192.0.0.0—223.255.255.255D类：组播地址，前导位为1110，即：1110.**.**.** 即224.0.0.0—239.255.255.255E类：保留地址，前导位为11110，即：11110*.**.**.** 即240.0.0.0—247.255.255.255其中A类、B类、C类IP地址可供普通用户使用。 （四）私有IP地址(记住)IP地址分为公有IP地址和私有IP地址(也称外部IP地址和内部IP地址，或称全局IP地址和专用IP地址)，在互联网中，公有IP地址可以被外网访问，私有IP地址仅用于内部网络使用，不能被外网访问。私有IP地址如下：A类：10.0.0.0—10.255.255.255B类：172.16.0.0—172.31.255.255C类：192.168.0.0—192.168.255.255 （五）IP地址的相关规定(记住)1.网络地址、主机地址、广播地址IP地址由“网络位+主机位”组成。网络地址：主机位全0主机地址：网络位全0直接广播地址：主机位全1举例：IP地址 201.161.20.18 的网络地址是201.161.20.0，主机地址是0.0.0.18，直接广播地址为201.161.20.255。 2.可用的IP地址主机位不可全0或全1（全0是网络地址，全1是广播地址）在一个网段内，最小的可用IP地址是“网络地址+1”，最大的可用IP地址是“广播地址-1”。举例：192.168.1.0～192.168.1.255网段中，可用的IP地址是：192.168.1.1～192.168.1.254 受限广播地址(或称为“有限广播地址”)32位全1的IP地址(255.255.255.255)表示受限广播地址。受限广播地址和直接广播地址的区别，举例：255.255.255.255和192.168.5.255。交换机转发广播，路由器不转发广播。 二、子网掩码子网掩码用来区别网络位和主机位，用1表示网络位，用0表示主机位。比如：A类IP地址的掩码：11111111.00000000.00000000.00000000 写成十进制 255.0.0.0也可以用/8来表示，表示前8位是网络位，比如：10.3.3.3/8B类IP地址的掩码：11111111.11111111.00000000.00000000 写成十进制 255.255.0.0也可以用/16来表示，表示前16位是网络位，比如：172.16.7.6/16C类IP地址的掩码：11111111.11111111.11111111.00000000 写成十进制 255.255.255.0也可以用/24来表示，表示前24位是网络位，比如：192.168.5.8/24子网掩码为255.255.255.255表示本网段只有1个IP地址，举例：电信运营商动态分配给用户的IP地址110.80.191.243和子网掩码255.255.255.255。 三、划分子网的三级网络结构将一个大的网络划分成几个较小的子网，变成“网络位+子网位+主机位”的三级结构。 （一）子网掩码的计算(★记住)10000000→128 (借1位)11000000→128＋64＝192 (借2位)11100000→128＋64＋32＝224 (借3位)11110000→128＋64＋32＋16＝240 (借4位)11111000→128＋64＋32＋16＋8＝248 (借5位)11111100→128＋64＋32＋16＋8＋4＝252 (借6位)11111110→128＋64＋32＋16＋8＋4＋2＝254 (借7位)11111111→128＋64＋32＋16＋8＋4＋2＋1＝255 (借8位) （二）子网划分计算向主机位借1位可以划分成2个子网，借2位划分成4个子网，借3位划分成8个子网，如下：28＝256，27＝128，26＝64，25＝32，24＝16，23＝8，22＝4，21＝2 （三）举例举例1：172.17.0.3/19子网掩码是多少 (借3位)子网掩码11111111.11111111.11100000.00000000 即255.255.224.0举例2：192.168.6.7/26子网掩码是多少 (借2位)子网掩码11111111.11111111.11111111.11000000 即255.255.255.192举例3：IP地址172.16.37.95，子网掩码为255.255.224.0，写出网络地址、主机地址和广播地址。解答：224表示借3位，172.16.37.95→172.16.00100101.95；网络地址：172.16.00100000.0→172.16.32.0 (主机位全0)主机地址：0.0.00000101.95→0.0.5.95 (网络位全0)广播地址：172.16.00111111.255→172.16.63.255 (主机位全1) 四、考题(记住方法)IP地址为126.150.28.57，子网掩码为255.240.0.0，那么地址类别是（），网络地址是（），直接广播地址是（），受限广播地址是（），主机地址是（），子网内的第一个可用IP地址是（），子网内的最后一个可用IP地址是（）解答：126.150.28.57/255.240.0.0→126.10010110.28.57地址类别是：A类网络地址是：126.144.0.0 (主机位全0)直接广播地址是：126.159.255.255 (主机位全1)受限广播地址是：255.255.255.255主机地址是：0.6.28.57 (网络位全0)子网内的第一个可用IP地址是：126.144.0.1 (网络地址+1)子网内的最后一个可用IP地址是：126.159.255.254 (广播地址-1)","tags":[{"name":"ip地址","slug":"ip地址","permalink":"http://yoursite.com/tags/ip地址/"},{"name":"子网掩码","slug":"子网掩码","permalink":"http://yoursite.com/tags/子网掩码/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"Linux常用命令(转载)","date":"2017-09-27T09:31:50.000Z","path":"2017/09/27/linux-command/","text":"转载","tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://yoursite.com/tags/linux命令/"}]},{"title":"递归遍历（用于解决输出所有路径问题）","date":"2017-08-25T02:50:09.000Z","path":"2017/08/25/DFS1/","text":"用于记录经典的DFS算法问题。 题目1：题目描述： 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public static ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext())&#123; int n = in.nextInt(); int m = in.nextInt(); dfs(1, m, n); for(ArrayList&lt;Integer&gt; tempList : res)&#123; for(int i=0; i&lt;tempList.size()-1; i++)&#123; System.out.print(tempList.get(i) + \" \"); &#125; System.out.println(tempList.get(tempList.size()-1)); &#125; &#125; &#125; public static void dfs(int index, int count, int n)&#123; if(count == 0)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); &#125; else &#123; for(int i=index; i&lt;=n &amp;&amp; i&lt;=count; i++)&#123; list.add(i); dfs(i+1, count-i, n); list.remove(list.size()-1); &#125; &#125; &#125;&#125;","tags":[{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/递归/"},{"name":"深度优先遍历","slug":"深度优先遍历","permalink":"http://yoursite.com/tags/深度优先遍历/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"}]},{"title":"根据二叉树的前、中序遍历来返回二叉树的后序遍历。","date":"2017-08-23T02:59:54.000Z","path":"2017/08/23/Tree1/","text":"记录一下做过的一题。 ###第一题题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1234567891011121314151617181920212223242526272829/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root = reConstructBinaryTree(pre, 0, pre.length-1, in, 0, in.length-1); return root; &#125; public TreeNode reConstructBinaryTree(int[] pre, int startpre, int endpre, int[] in, int startin, int endin)&#123; if(startpre&gt;endpre || startin&gt;endin)&#123; return null; &#125; TreeNode root = new TreeNode(pre[startpre]); for(int i=startin; i&lt;=endin; i++)&#123; if(pre[startpre] == in[i])&#123; root.left = reConstructBinaryTree(pre, startpre+1, startpre+i-startin, in, startin, i-1); root.right = reConstructBinaryTree(pre, i-startin+startpre+1, endpre, in, i+1, endin); &#125; &#125; return root; &#125;&#125; 将问题转为递归问题，关键在于 12root.left = reConstructBinaryTree(pre, startpre+1, startpre+i-startin, in, startin, i-1); root.right = reConstructBinaryTree(pre, i-startin+startpre+1, endpre, in, i+1, endin); ###第二题题目描述：git是一种分布式代码管理工具，git通过树的形式记录文件的更改历史，比如： base’&lt;–base&lt;–A&lt;–A’ ^ | — B&lt;–B’ 小米工程师常常需要寻找两个分支最近的分割点，即base.假设git 树是多叉树，请实现一个算法，计算git树上任意两点的最近分割点。 （假设git树节点数为n,用邻接矩阵的形式表示git树：字符串数组matrix包含n个字符串，每个字符串由字符’0’或’1’组成，长度为n。matrix[i][j]==’1’当且仅当git树种第i个和第j个节点有连接。节点0为git树的根节点。） 输入：[01011,10100,01000,10000,10000],1,2输出：1 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.List; public class Solution &#123; public int getSplitNode(String[] matrix, int indexA, int indexB) &#123; if(indexA==indexB) return indexA; int nodeNum = matrix.length; int tree[] = new int[nodeNum]; boolean flag[] = new boolean[nodeNum]; for(int i=0; i&lt;tree.length; i++)&#123; tree[i]=i; &#125; dfs(0, tree, matrix); int a = indexA; int b = indexB; while(tree[a]!=a)&#123; flag[a] = true; a = tree[a]; &#125; while(tree[b]!=b)&#123; if(flag[b])&#123; break; &#125; b = tree[b]; &#125; return b; &#125; public void dfs(int root, int[] tree, String[] matrix)&#123; for(int i=0; i&lt;tree.length; ++i)&#123; if(matrix[root].charAt(i) == '1' &amp;&amp; tree[i]==i &amp;&amp; i!=0)&#123; tree[i] = root; dfs(i, tree, matrix); &#125; &#125; &#125; &#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"二叉树","slug":"二叉树","permalink":"http://yoursite.com/tags/二叉树/"}]},{"title":"c#委托学习，并分析c#中委托和接口的作用区别","date":"2017-08-11T07:53:59.000Z","path":"2017/08/11/c#Delegate&Interface/","text":"首先我觉得c#中的新概念委托所能实现的功能，接口都可以实现，那么新概念委托究竟和接口有什么区别，加入它的意义是什么，让我用此文记录一下。 delegate委托的定义就不赘述了，来讲一下它的作用。 委托的作用： 委托类似于C++函数指针，但它们是类型安全的。 委托允许将方法作为参数进行传递。（接口也可以） 委托可用于定义回调方法（接口也可以）。 委托可以链接在一起；例如，可以对一个事件调用多个方法。 方法不必与委托签名完全匹配。 下面关于使用委托进行实现快排的例子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class QuickSortClass&#123; public QuickSortClass() &#123; &#125; static void QuickSort&lt;T&gt;(T[] ArrayList, int left, int right, CompareMethod&lt;T&gt; Compare) &#123; if (left &lt; right) &#123; int middle = QSort(ArrayList, left, right, Compare); QuickSort(ArrayList, left, middle - 1, Compare); QuickSort(ArrayList, middle + 1, right, Compare); &#125; &#125; private delegate bool CompareMethod&lt;T&gt;(T a, T b); static int QSort&lt;T&gt;(T[] ArrayList, int left, int right, CompareMethod&lt;T&gt; Compare) &#123; T point = ArrayList[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; Compare(point, ArrayList[right])) &#123; right--; &#125; Swap(ArrayList, left, right); while (left &lt; right &amp;&amp; Compare(ArrayList[left], point)) &#123; left++; &#125; Swap(ArrayList, left, right); &#125; return left; &#125; static void Swap&lt;T&gt;(T[] ArrayList, int left, int right) &#123; T temp = ArrayList[left]; ArrayList[left] = ArrayList[right]; ArrayList[right] = temp; &#125; static bool Compare(int a, int b) &#123; if (a &lt;= b) &#123; return true; &#125; return false; &#125; static void Main(String[] args) &#123; int[] ArrayList = &#123;1, 4, 3, 2, 7, 3, 8, 0, 11&#125;; QuickSortClass.QuickSort(ArrayList, 0, ArrayList.Length-1, QuickSortClass.Compare); foreach (var temp in ArrayList) &#123; Console.Write(temp + \" \"); &#125; Console.ReadKey(); &#125;&#125; 首先，可以看出来委托签名作为定义方法的模板提供了类似于接口的功能，对于一个方法只要求提供签名部分，让不同的类去实现不同的方法体。其次，将方法当做类型的思想也和接口十分相似，因为接口是一个只定义了方法签名的超类（接口&amp;抽象类），并且具备类型兼容性，例如实现了IComparable接口的EspecialInt类，它的实例化函数可以写成：IComparable e = new EspecialInt();因此，用接口作为方法的参数类型可以实现函数回调和将函数作为参数的效果。所以就上述例子来看，接口和委托都能实现函数回调和将方法作为参数传递的功能，但是接口必须依赖于其他类的实现而存在（除了使用匿名函数），而委托是相对独立的类型。 Aciton和Func(1)delegate delegate是我们常用的一种声明。 Delegate至少0个参数，至多32个参数，可以无返回值，也可以有返回值。 (2)Action Action是无返回值得泛型委托。 Action 表示无参，无返回值的委托。 Action&lt;int, string&gt;表示有传入参数int, string无返回值的委托。 Action&lt;int, string, bool&gt;表示有传入参数int, string, bool无返回值的委托。 Action至少0个参数，至多16个参数，无返回值。 ex: public void Test&lt;T&gt;(Action&lt;T&gt; action, T a){action(a)} (3)Func Func是有返回值的泛型委托。 Func表示无参，返回值为int的委托。 Func&lt;int, string, object&gt;表示传入参数为int, string, 返回值为object型的委托。 Func&lt;T1, T2, T3, int&gt;表示传入参数为T1,T2,T3(泛型)返回值为int型的委托。 Func至少0个参数，至多16个参数，根据返回值泛型返回。必须有返回值,不可以void。 ex: public int Test&lt;T1, T2&gt;(Func&lt;T1, T2, int&gt; func, T1 a, T2 b){return func(a, b)} 多播委托一个委托可以包含多个方法调用，称为多播委托。 当调用多播委托时，它连续调用每一个方法，当调用过程中，委托必须为同类型（这点非常关键，但并不是表示返回值类型和参数类型都必须完全相同，因为委托具有允许方法不必与委托签名完全匹配的特点。这点与接口不同，各有利弊）。 返回类型一般为void,这样才能将委托的单个实例合并为一个多播委托。如果委托具有返回返回值/或输出参数，它将返回最后调用的方法的返回值和参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 /// &lt;summary&gt;/// 多播委托/// &lt;/summary&gt;public class MultiDelegate&#123; private delegate int DemoMultiDelegate(out int x); private static int Show1(out int x) &#123; x = 1; Console.WriteLine(\"This is the first show method:\"+x); return x; &#125; private static int Show2(out int x) &#123; x = 2; Console.WriteLine(\"This is the second show method:\"+x); return x; &#125; private static int Show3(out int x) &#123; x = 3; Console.WriteLine(\"This is the third show method:\"+x); return x; &#125; /// &lt;summary&gt; /// 调用多播委托 /// &lt;/summary&gt; public void Show() &#123; DemoMultiDelegate dmd = new DemoMultiDelegate(Show1); dmd += new DemoMultiDelegate(Show2); dmd += new DemoMultiDelegate(Show3);//检查结果 int x = 5; int y= dmd(out x); Console.WriteLine(y); &#125;&#125;/*----------------------多播委托---------------------------------*/MultiDelegate multiDelegate = new MultiDelegate();multiDelegate.Show(); 输出的结果是3. 这里讲一下多播委托在观察者模式中相比接口的好处。首先被观察者本身是不知道多少个观察者在观察他，他需要通知多少个观察者（为了让观察者和被观察者更好地封装，使修改观察者代码的时候不需要考虑被观察者的实现），因此，一般需要用成员变量List\\&lt;T>，以及实现addListener()和deleteListener()方法。然而委托却可以通过多播委托来省去这部分的实现，直接让一个委托去包含所有的方法调用。 匿名函数和Lambda表达式当使用委托时，不想命名函数名，可以使用匿名函数（适合用于不常被调用的方法。）下面看一下匿名函数的例子。 1234567Func&lt;int, string, bool&gt; func1 = delegate(int a, string name)&#123; if(name.Length &lt;= a) &#123; return true; &#125; else return false;&#125; 除此之外，还有更加简单的形式就是Lambda表达式。上述的代码可以用Lambda表达式表示： 12345678Func&lt;int, string, bool&gt; func1 = (a, name) =&gt;&#123; if(name.Length &lt;= a) &#123; return true; &#125; else return false;&#125; 如果参数和返回值只有一个，那么可以省去()和return。例如：Func&lt;int, int&gt; func1 = a =&gt; a+1等于Func&lt;int, int&gt; func1 = delegate(int a){return a+1;} 事件事件(event)基于委托，为委托提供了一个发布/订阅机制，我们可以说事件是一种具有特殊签名的委托。 事件： 事件(event)是类或对象向其他类或对象通知发生的事情的一种特殊签名的委托。 public event委托类型事件名。 事件使用event关键词来声明，他的返回值是一个委托类型。 通常事件的命名，以名字+Event作为它的名字。 事件只能定义为类的成员变量，不能定义为局部变量。 事件和委托的区别：事件就是一个狭义的委托,也就是事件是一个用于事件驱动模型的专用委托.你可以在客户代码中直接调用委托来激发委托指向的函数,而事件不可以，事件的触发只能由服务代码自己触发。也就是说，事件的触发调用以及’=’（赋值）操作，只能在定义事件的类中调用(事件的这2个方法是private的)，而在其他类中不能使用。其他类中只能使用”+=”&amp;”-=”操作给委托进行注册和注销操作。好处就是：对委托在发布/订阅机制中进行了更好的封装，提高了安全性。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"委托delegate","slug":"委托delegate","permalink":"http://yoursite.com/tags/委托delegate/"},{"name":"c#","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"从观察者设计模式比较接口和委托","date":"2017-08-11T07:51:52.000Z","path":"2017/08/11/Publish:Subscribe/","text":"用本文记录分别通过接口和委托来实现观察者设计模式，并比较两者的区别。 场景描述假设我们要去M记吃饭，我们点完餐和付完钱后不是立刻拿到我们所点的美食，店员需要时间给我们去准备这些食物，但我们不清楚他们什么时候能准备好，所以我们不应该频繁地去询问他们是否准备好了，而应该让店员去主动提醒我们，这种情况下用观察者设计模式去实现，既可以让观察者和被观察者的逻辑完全分开，也让代码更具有可维护性。 接口实现观察者模式首先通过接口来实现观察者设计模式，下面是代码： 接口部分代码：这里只给出观察者部分的接口。（最好被观察者(Subject)本身关于观察者的信息和方法也用超类进行规范） 123456789using System;namespace Mytest&#123; public interface ICateenObserver &#123; void GetNotify(); &#125;&#125; 被观察者部分代码: 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections.Generic;namespace Mytest&#123; public class Cateen &#123; public Dictionary&lt;int, ICateenObserver&gt; guests; private int count; public Cateen () &#123; guests = new Dictionary&lt;int, ICateenObserver&gt;(); count = 0; &#125; public void addGuest(ICateenObserver guest) &#123; count++; guests.Add(count, guest); &#125; public void Notify(int num) &#123; ICateenObserver tempICateenObserver; if (guests.TryGetValue(num, out tempICateenObserver)) &#123; tempICateenObserver.GetNotify(); &#125; else &#123; Console.WriteLine(\"None this Guest!\"); &#125; &#125; &#125;&#125; 观察者部分代码：这里只给出一种观察者。 1234567891011121314151617181920212223242526 public class LunchGuy : ICateenObserver &#123; private int _num; private string name&#123;get;set;&#125; public int num &#123; get &#123; return _num; &#125; set &#123; _num = value; &#125; &#125; public LunchGuy (string name) &#123; this.name = name; &#125; public void GetNotify()&#123; Console.WriteLine(\"It's time for \" + name +\" to get lunch!\"); &#125; &#125;&#125; 运行部分： 123456789101112131415161718192021222324using System;namespace Mytest&#123; public class Test &#123; public Test() &#123; &#125; static void Main(String[] args) &#123; Cateen c = new Cateen(); c.addGuest(new LunchGuy(\"hello\")); c.addGuest(new LunchGuy(\"world\")); c.addGuest(new LunchGuy(\"HiphopMan\")); c.addGuest(new LunchGuy(\"tt\")); //int num = Convert.ToInt32(Console.ReadLine()); c.Notify(3); Console.ReadKey(); &#125; &#125;&#125; 运行结果： 委托(事件)实现观察者模式这里，我们通过委托来实现相同功能。 被观察者部分代码： 12345678910111213141516171819202122232425262728293031323334using System;namespace DelegatePattern&#123; public class Cateen &#123; public int count; //委托 public delegate void GetNotifyMethod(int num); public event GetNotifyMethod GetNotifyEvent; public Cateen() &#123; count = 0; &#125; public void Notify(int num) &#123; if (GetNotifyEvent != null) &#123; Delegate[] tempDelegate1 = GetNotifyEvent.GetInvocationList(); int delegateCount1 = tempDelegate1.Length; GetNotifyEvent(num); Delegate[] tempDelegate2 = GetNotifyEvent.GetInvocationList(); int delegateCount2 = tempDelegate2.Length; if (delegateCount1 == delegateCount2) &#123; Console.WriteLine(\"None this Guest!\"); &#125; &#125; &#125; &#125;&#125; 观察者部分代码： 12345678910111213141516171819202122232425262728293031323334353637383940using System;namespace DelegatePattern&#123; public class LunchGuy &#123; private int _num; private string name&#123;get;set;&#125; private Cateen cateen; public int num &#123; get &#123; return _num; &#125; set &#123; _num = value; &#125; &#125; public LunchGuy(string name, Cateen cateen) &#123; this.name = name; this.cateen = cateen; this.num = ++cateen.count; cateen.GetNotifyEvent += this.GetNotify; &#125; public void GetNotify(int num) &#123; if (this.num == num) &#123; Console.WriteLine(\"It's time for \" + name +\" to get lunch!\"); cateen.GetNotifyEvent -= this.GetNotify; &#125; &#125; &#125;&#125; 运行部分： 123456789101112131415161718192021222324using System;namespace DelegatePattern&#123; public class Test &#123; public Test() &#123; &#125; static void Main(String[] args) &#123; Cateen c = new Cateen(); LunchGuy LunchGuy1 = new LunchGuy(\"hello\", c); LunchGuy LunchGuy2 = new LunchGuy(\"world\", c); LunchGuy LunchGuy3 = new LunchGuy(\"santa\", c); LunchGuy LunchGuy4 = new LunchGuy(\"HipPopMan\", c); c.Notify(3); c.Notify(5); c.Notify(3); Console.ReadKey(); &#125; &#125;&#125; 运行结果： 委托其实就和函数指针差不多，将函数当做参数来传递，上面的例子中，就是将每个LunchGuy类的GetNotify(int num)方法进行传递给被观察类来调用，也就是说被观察者在观察者进行注册之后，被观察者中的委托(事件)GetNotifyEvent成员变量记录了各个观察者的GetNotify(int num)的方法地址。 然而，接口在实现观察者模式的时候，是通过用List\\&lt;ICateenObserver>去记录了实现了ICateenObserver接口的对象，并通过这些实例化的对象来调用这些对象所实现的接口方法，当然也可以调用这些对象中允许其他类访问的成员变量和方法。也就是说被观察者(Subject)在观察者进行注册之后，被观察中的List\\&lt;ICateenObserver> guests成员变量去记录了各个观察者对象的地址。 从上面2段话，可以看出来接口和委托在实现发布/订阅机制（被观察者模式）设计模式中，一些关键的区别。委托仅仅记录了各个观察者实现的特殊方法的地址，而用接口实现记录了各个观察者对象的地址，也就是说如果仅仅使用规定的方法用委托更加方便，然而接口却可以管理观察它的观察者的成员变量和其他方法（但是不推荐使用，这样分开观察者和被观察者的意义就没了）。 因此，在发布/订阅机制中，推荐用委托来实现，更具有封装性。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"委托delegate","slug":"委托delegate","permalink":"http://yoursite.com/tags/委托delegate/"},{"name":"c#","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"正则表达式","date":"2017-08-08T02:44:47.000Z","path":"2017/08/08/regex/","text":"此文是用于记录正则表达式学习。 常用元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配行的开始 $ 匹配行的结束 常用反义字符 代码 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 常用重复限定字符 代码 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 在正则表达式中，\\是转义字符，. 是元字符，如果要表达\\ . ,则需要使用\\\\ \\. \\* 想了想，这次还没太深的理解还是引用下别人的吧，向大佬低头。转载 择一匹配和括号直接给出例子 例如中国的电话有3种规则: (010)12345678 010-12345678 010 12345678 ps:第一位数字一定要是0，第一位号码一定要是1，规则3选一。 string pattern1 = “^(0[0-2]{2}[- ]{1}|\\(0[0-2]{2}\\))1[0-9]{7}$” Console.WriteLine(Regex.IsMatch(&quot;010-12345678&quot;, pattern1)); //get result true","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"var、let、const区别","date":"2017-05-25T07:58:05.000Z","path":"2017/05/25/var&let/","text":"随着ES6规范的到来，Js中定义变量的方法已经由单一的 var 方式发展到了 var、let、const 三种之多。var 众所周知，可那俩新来的货到底有啥新特性呢？到底该啥时候用呢？ 引用别人的博客。var、let、const的区别","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"js语法","slug":"js语法","permalink":"http://yoursite.com/tags/js语法/"}]},{"title":"面试经验总结——网易游戏面试(游戏运营)","date":"2017-05-08T11:20:48.000Z","path":"2017/05/08/mianshi/","text":"上周远赴广州参加网易游戏的面试，虽然知道机会不大，但总忍不住幻想一把。即使是命中注定，当结果得知的那刹那还是难受，今天作个总结，就算是翻过新的篇章吧。 1.最重要的一点：尽可能地展示自己。在自己也没把握很好地回答问题时，尽可能地说出自己的观点非常重要。即时没有答对，也能让面试官看到你的态度和你的口才。 2.回答问题时，尽可能从多角度、多层次回答。这次犯了致命的失误就是，在回答以乖离性百万亚瑟王为例，你作为游戏运营方如何挽留玩家这个问题的时候，由于在这个问题上有太深的玩家方面上的看法。因此回答时就完全侧重了从玩家角度上回答，忽略了从运营方角度上总结如何挽留玩家。例如，玩家希望普通玩家与氪金玩家的差距不要太大，从运营方来讲，收入的主要来源是这些氪金玩家，但是普通玩家也是游戏世界的参与者甚至是游戏的宣传、推广者，所以可以通过增加稍微困难的渠道使普通玩家缩小与氪金玩家的差距的方法（用时间弥补），让氪金玩家能获得氪金的快感，普通玩家也能享受游戏的乐趣。这样的回答，更具客观性和认同感，比较有说服力。 3.总结回答时，将所抛出的问题归结成一类问题或者更客观地概述这也是这次面试没有注意到的问题，例如：我提出亚瑟王的卡片名声系统并没有太大的乐趣同时活动卡的获得太过简单，容易使玩家厌倦，从而导致玩家的流失，在总结时，应将该问题归结为：亚瑟王除了绚丽的卡面和大牌的配音外，应该在玩法机制上（任务机制上）加大玩家的难度，从而使玩家获得更大的成就感，不容易使玩家对游戏厌倦。当你在提出问题的时候，面试官不一定能理解你所要表达的意思，因此客观的总结既可以让面试官再次深入理解你想表达的意思，也能使你的语言更具逻辑性。 4.展示你的专业在这工作上能有什么优势游戏运营方面需要你对用户的需求、用户的流失情况、用户阶段分布等数据有很深的了解，我作为计算机专业，优势就是在于对这些数据处理和分析。 5.运营方面的干货=。=","tags":[{"name":"面试经验","slug":"面试经验","permalink":"http://yoursite.com/tags/面试经验/"}]},{"title":"TCP/IP协议 三次握手与四次挥手","date":"2017-04-20T08:17:38.000Z","path":"2017/04/20/tcp-ip1/","text":"此文是转载1.TCP报文格式TCP/IP协议的详细信息参看《TCP/IP协议详解》三卷本。下面是TCP报文格式图：上图中有几个字段需要重点介绍下： 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 需要注意的是： （A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。 2.客户端TCP状态迁移：CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED 3.服务器TCP状态迁移：CLOSED-&gt;LISTEN-&gt;SYN_RCVD-&gt;ESTABLISHED-&gt;CLOSE-WAIT-&gt;LAST_ACK-&gt;CLOSED LISTEN - 侦听来自远方TCP端口的连接请求 SYN_SENT - 在发送连接请求后等待匹配的连接请求 SYN_RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认 ESTABLISHED - 代表一个打开的连接，数据可以传送给用户 FIN_WAIT1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认 FIN_WAIT2 - 从远程TCP等待连接中断请求 CLOSE_WAIT - 等待从本地用户发来的连接中断请求 CLOSING - 等待远程TCP对连接中断的确认 LAST_ACK - 等待原来发向远程TCP的连接中断请求的确认 TIME_WAIT - 等待足够的时间以确保远程TCP接收到连接中断请求的确认 CLOSED - 没有任何连接状态 4.三次握手TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 （1）第一次握手： 建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B的确认。（2）第二次握手： 服务器B收到SYN包，必须确认客户端A的SYN(ACK=j+1)，同时自己也发送一个SYN包（SYN=K），即SYN+ACK包，此时服务器进入SYN_RECV状态。（3）第三次握手： 客户端A收到服务器B的SYN+ACK包，向服务器B发送确认包ACK（ACK=K+1），此包发送完毕，客户端A和服务端B进入ESTABLISHED状态，完成三次握手。完成三次握手后，客户端与服务端开始数据传输。ACK（确认号）：其数值等于发送方的发送序号+1（即接受方期待接受的下一个序列号） 5.四次挥手由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方执行主动关闭，另一方被动关闭。TCP连接的拆除需要发送4个包，因此被称为四次挥手客户端和服务端均可主动关闭，以下挥手例子是客户端主动关闭（1） 第一次挥手: 客户端A发送一个FIN，用来关闭客户端A到服务器B的数据传送。（2） 第二次挥手: 服务端B收到这个FIN，它发回一个ACK，确认序号为收到的序号+1。和SYN一样，一个FIN需要占用一个序号。（3） 第三次挥手: 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。（4） 第四次挥手: 客户端A发回ACK报文确认，并将确定序号设置为收到的序号+1。","tags":[{"name":"TCP/IP协议","slug":"TCP-IP协议","permalink":"http://yoursite.com/tags/TCP-IP协议/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"String、StringBuffer与StringBuilder之间的区别","date":"2017-04-18T15:04:48.000Z","path":"2017/04/18/StringBuilder&StringBuffer&String/","text":"平时敲代码是一般都是使用String，但查看别人代码的使用却会经常用到StringBuffer和StringBuilder。因此，记录下String、StringBuffer与StringBuilder的区别。 1.三者在执行速度上的区别:StringBuilder&gt;StringBuffer&gt;String 2.String &lt; (StringBuffer&amp;StringBuilder)的原因： String:字符串常量 StringBuffer&amp;StringBuilder：字符串变量因此从这2点可以看出，String是“字符串常量”,也就是不可改变的对象。但是从平时的经验，会对这观点有疑问，如下： 123String str = \"Hello\"; str = str + \" World!\"; System.out.print(str); //result: Hello World!\" 上文，我们明明修改了String类型变量str的值，却为什么说是没有改变呢？其实这是由于JVM的机制问题，JVM是这样解析这段代码的：首先创建对象str,赋予一个Hello,然后再创建一个新的对象str用来执行第二行代码，也就是说我们之前对象str并没有发生变化，所以String是不可改变对象。由于这种机制，每当用String操作字符串时，实际上是不断的创建新的对象，而原来的对象就会变成垃圾被GC回收掉，可想而知这样执行的效率有多低。 而StringBuffer与StringBuilder就不一样了，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上的操作，因此速度快。 3.StringBuilder与StringBuffer StringBuilder：线程非安全的 StringBuffer：线程安全的当我们在字符串缓冲区被多个线程使用时，JVM不能保证StringBuilder的操作时安全的（其速度是最快的），但是能保证StringBuffer的操作时安全的。当然，由于StringBuilder比StringBuffer的速度要快，因此在单线程下使用StringBuilder更好。 4.三者使用情况总结： String:如果要操作少量的数据。 StringBuilder单线程下字符串缓冲区大量数据操作。 StringBuffer多线程下字符串缓冲区大量数据操作。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"String","slug":"String","permalink":"http://yoursite.com/tags/String/"}]},{"title":"Hello World","date":"2017-04-13T19:47:03.000Z","path":"2017/04/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]